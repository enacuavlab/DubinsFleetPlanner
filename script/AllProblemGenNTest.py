# Copyright (C) 2025 Mael FEURGARD <mael.feurgard@enac.fr>
# 
# This file is part of DubinsFleetPlanner.
# 
# DubinsFleetPlanner is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# DubinsFleetPlanner is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with DubinsFleetPlanner.  If not, see <https://www.gnu.org/licenses/>.

from FormationProblemGenerator import \
    Formation,ACStats,AC_PP_Problem,write_pathplanning_problem_to_CSV,\
    list_all_formations,generate_basic_formation_moves,generate_formation_transitions
    
from ProblemGenerator import \
    Pose3D,RandomPathPlanningGenerator
    
import numpy as np
import typing,os,subprocess,pathlib,csv

__REF_CSV_HEADER = "Test input;Success;False positive;Iterations;Duration(ns);Threads;Possible paths;Initial guessed time;Final optained time".split(';')

def check_results(case_dir:pathlib.Path,sol_dir:pathlib.Path) -> bool:
    sol_file = sol_dir / "summary.csv"
    if not(sol_file.exists()):
        return False
    
    todos = set(p.resolve() for p in case_dir.iterdir() if p.is_file() and p.suffix.lower() == '.csv')
    
    with open(sol_file) as f:
        reader = csv.reader(f,delimiter=';')
        
        header = next(reader)
        for h,r in zip(header,__REF_CSV_HEADER):
            if h != r:
                print("WRONG HEADER")
                print(f"Expected: {__REF_CSV_HEADER}")
                print(f"Got     : {header}")
                return False
        
        tested = set(pathlib.Path(l[0]).resolve() for l in reader)
        
        diff = todos.difference(tested)
        
        if len(diff) == 0:
            return True
        else:            
            print(diff)
            return False
        

def solve_problems(solver:pathlib.Path,src_dir:pathlib.Path,dest_dir:pathlib.Path,
                   separation:float, wind:tuple[float,float],threads:int,
                   **kwargs) -> subprocess.CompletedProcess[bytes]:
    cmd = []
    cmd.append(str(solver.resolve()))
    cmd.append(str(src_dir.resolve()))
    cmd.append(str(dest_dir.resolve()))
    cmd.append(str(separation))
    
    cmd.append(str(wind[0]))
    cmd.append(str(wind[1]))
    
    cmd.append('-t')
    cmd.append(str(threads))
    
    for k,v in kwargs.items():
        cmd.append(k)
        
        if v is None:
            continue
        
        cmd.append(str(v))
    
    return subprocess.run(cmd)

if __name__ == '__main__':
    import argparse,multiprocessing,time
    
    parser = argparse.ArgumentParser('Formation Path Planning Problem Generator',
                                     description="Generate formation-nased path planning problems from a list of known formations."
                                     "The end points may be generated by shifting and rotating the initila formation, "
                                     "or transitioning from a formation to another",
                                     epilog="Usual statistics: Airliner:\n"
                                     " - Airspeed       : 250 knots (4.166 NM/min)\n"
                                     " - Turn radius    : 1.33 NM\n"
                                     " - Min separation : 5 NM\n\n"
                                     "Lab fixed wing:\n"
                                     " - Airspeed       : 15 m/s\n"
                                     " - Turn radius    : 40 m\n"
                                     " - Min separation : 80 m\n\n",
                                     formatter_class=argparse.RawTextHelpFormatter)
    
    parser.add_argument('nlines',type=int,help='Number of lines of aicraft (total is nlines * ncols)')
    parser.add_argument('ncols',type=int,help='Number of columns of aicraft (total is nlines * ncols)')
    parser.add_argument('mdist',type=float,help='Minimal distance separating aircraft')
    parser.add_argument('output',type=str,help='Destination folder for test cases (and the eventual solutions).')
    
    parser.add_argument('-m','--dist-mult',dest='dist_mult',
                        type=float,help='Multiplier for mdist for setting the formation separation. SHould be larger than 1. Default to 1.1',
                        default=1.1)
    
    parser.add_argument('-v','--airspeed',dest='airspeed',
        type=float, help='Airspeed for all aircraft. Default to 1.',default=1.)

    parser.add_argument('-c','--climb',dest='climb',
        type=float, help='Climb speed for all aircraft. Default to 1.',default=1.)

    parser.add_argument('-r','--turn-radius',dest='turn_radius',
        type=float, help='Minimal turn radius for all aircraft. Default to 1.',default=1.)
    
    parser.add_argument('-x','--x-range',dest='x_range',
        nargs=2,help='Low and high values for initial random point generation, X axis. Default to (0,1)',
        default=(0.,1.))

    parser.add_argument('-y','--y-range',dest='y_range',
        nargs=2,help='Low and high values for initial random point generation, Y axis. Default to (0,1)',
        default=(0.,1.))

    
    parser.add_argument('-d','--d-range',dest='d_range',
                        nargs=2,help='Disk based generation of endpoints. Specifies low and high values for disk radius as a multiple of turn radius.'
                        'Default to (9,11)',
                        default=(9,11))

    
    parser.add_argument('-M',type=int,
                        help="Number of test cases to generate (repeat the arguments, increment the seed). Default to 100.",
                        default=100)
    
    parser.add_argument('-p','--processes',dest='processes',
                        type=int,help="Number of processes used to generate cases and solve problems. Default to 0 (i.e. use as many as possible).",
                        default=0)
    
    parser.add_argument('-s','--solver',dest='solver',
                        help='If defined, path to the solver. In that case, it will be automatically called to solve the generated cases',
                        default=None)
    
    parser.add_argument('-w','--wind',dest='wind', nargs=2,
                        help='XY Wind, as a pair of values (X,Y). Default to (0,0), i.e. no wind.',
                        default=(0,0))
    
    parser.add_argument('--redo',dest='redo',action='store_true',
                        help="Flag. If set, force restarting the solver on every directory.\
                        Otherwise, skip the directories where a complete 'summary.csv' file is found. Default to False.",
                        default=False)
    
    args = parser.parse_args()
    
    ## Gathering parsed values and closely related
    
    nlines  = args.nlines
    ncols   = args.ncols
    N = nlines * ncols
    
    mdist = args.mdist
    assert args.dist_mult >= 1.
    endpoint_dist = mdist * args.dist_mult
    
    dir = pathlib.Path(args.output)
    
    rng_pb_dir                 = dir / "rng" / "cases"
    os.makedirs(rng_pb_dir,exist_ok=True)
    formation_pb_dir           = dir / "formation" / "cases"
    os.makedirs(formation_pb_dir,exist_ok=True)
    rng_to_formation_pb_dir    = dir / "rng_to_formation" / "cases"
    os.makedirs(rng_to_formation_pb_dir,exist_ok=True)
    
    rng_sol_dir                 = dir / "rng" / "solutions"
    os.makedirs(rng_sol_dir,exist_ok=True)
    formation_sol_dir           = dir / "formation" / "solutions"
    os.makedirs(formation_sol_dir,exist_ok=True)
    rng_to_formation_sol_dir    = dir / "rng_to_formation" / "solutions"
    os.makedirs(rng_to_formation_sol_dir,exist_ok=True)
    
    
    airspeed    = args.airspeed
    climb       = args.climb
    turn_radius = args.turn_radius
    
    stats = [ACStats(i,airspeed,climb,turn_radius) for i in range(N)]
    
    x_range = (float(args.x_range[0]),float(args.x_range[1]))
    y_range = (float(args.y_range[0]),float(args.y_range[1]))
    z_range = (0,0)
    
    midpoint = Pose3D(
        (x_range[0]+x_range[1])/2,
        (y_range[0]+y_range[1])/2,
        (z_range[0]+z_range[1])/2,
        0.)
    
    d_range = (float(args.d_range[0]),float(args.d_range[1]))
    M = args.M
    
    processes   = args.processes
    solver      = args.solver
    wind        = args.wind
    
    seed = abs(hash(args.output))
    
    dts = np.zeros(N)
    
    all_formations = list_all_formations(ncols,nlines,endpoint_dist)
    formations_std_poses:list[list[Pose3D]] = []
    for f in all_formations:
        
        f = f.apply_rotation().to_barycentric_coords()
        f.center[0] = midpoint.x
        f.center[1] = midpoint.y
        f.center[2] = midpoint.z
        endposes = f.get_abs_positions()
        formations_std_poses.append(
            [Pose3D.from_array(a) for a in endposes]
        )
        f.center = np.zeros(3)
    
    ## Formation problems
    
    formation_depl = endpoint_dist * N
    
    for f in all_formations:
        pb_list = generate_basic_formation_moves(f,stats,formation_depl)
        
        for pb,turn_name in pb_list:
            write_pathplanning_problem_to_CSV(formation_pb_dir / (f.name+"_"+turn_name+".csv"),pb,True)
            
    for pb,name in generate_formation_transitions(all_formations,stats,formation_depl):
        write_pathplanning_problem_to_CSV(formation_pb_dir / (name+".csv"),pb,True)
        
    ## Random problems
    
    def problem_gen(m:int):
        print(f"Generating case number {m}... ")
        
        gen = RandomPathPlanningGenerator(seed+m,verbose=0)
        
        og_pts = gen._generate_uniform_pts(N,x_range,y_range,z_range)
        
        sep_pts = gen._repulse_separate(og_pts,endpoint_dist)
        angles = gen.rng.uniform(0,2*np.pi,N)
        
        rng_starts = [Pose3D(p[0],p[1],p[2],a) for p,a in zip(sep_pts,angles)]
        
        # Fully random to fully random poses (2D)
        
        end_pts = gen._generate_uniform_pts(N,x_range,y_range,z_range)
        
        sep_end_pts = gen._repulse_separate(end_pts,endpoint_dist)
        end_angles = gen.rng.uniform(0,2*np.pi,N)
        
        rng_ends = [Pose3D(p[0],p[1],p[2],a) for p,a in zip(sep_end_pts,end_angles)]
        
        rng_problem = [(stat,start,end,dt) for stat,start,end,dt in zip(stats,rng_starts,rng_ends,dts) ]

        rng_file = rng_pb_dir / f"rng_rng_{m}.csv"
        
        write_pathplanning_problem_to_CSV(rng_file,rng_problem,True)
        
        # Fully random to reasonnably close random poses (2D)
        
        drange = (float(d_range[0]),float(d_range[1]))
        latrange = (0.,0.)
        
        disk_og_ends = gen._generate_endpoints_in_disk(sep_pts,drange,latrange)
            
        disk_sep_ends = gen._repulse_separate(disk_og_ends,endpoint_dist)
        disk_end_angles = gen.rng.uniform(0,2*np.pi,N)
        
        disk_ends = [Pose3D(p[0],p[1],p[2],a) for p,a in zip(disk_sep_ends,disk_end_angles)]
        
        disk_problem = [(stat,start,end,dt) for stat,start,end,dt in zip(stats,rng_starts,disk_ends,dts) ]

        disk_file = rng_pb_dir / f"rng_disk_{m}.csv"
            
        write_pathplanning_problem_to_CSV(disk_file,disk_problem,True)
        
        # Fully random to formation (2D)
        for f,f_ends in zip(all_formations,formations_std_poses):
            f_problem = [(stat,start,end,dt) for stat,start,end,dt in zip(stats,rng_starts,f_ends,dts) ]
            
            f_file = rng_to_formation_pb_dir / f"rng_to_{f.name}_{m}.csv"
            
            write_pathplanning_problem_to_CSV(f_file,f_problem,True)
            
        print(f"Done with {m}!")
    
    with multiprocessing.Pool(processes if processes > 0 else None) as p:
        p.map(problem_gen,range(args.M))
        
    ## Solving
    
    extra_args = {'-l':None}
    
    if solver is not None:
        solver = pathlib.Path(solver)
        
        rng_done = check_results(rng_pb_dir,rng_sol_dir)
        if args.redo or not(rng_done):
            solve_problems(solver,rng_pb_dir,rng_sol_dir,mdist,wind,processes,**extra_args)
        
        print("\n\n")
        print("===============================================")
        print("==           Done with RNG problems          ==")
        print("===============================================\n\n")
        time.sleep(1.)
        
        formation_done = check_results(formation_pb_dir,formation_sol_dir)
        if args.redo or not(formation_done):
            solve_problems(solver,formation_pb_dir,formation_sol_dir,mdist,wind,processes,**extra_args)
            
        print("\n\n")
        print("===============================================")
        print("==    Done with RNG to formation problems    ==")
        print("===============================================\n\n")
        
        time.sleep(1.)
        
        rng_to_formation_done = check_results(rng_to_formation_pb_dir,rng_to_formation_sol_dir)
        if args.redo or not(rng_to_formation_done):
            solve_problems(solver,rng_to_formation_pb_dir,rng_to_formation_sol_dir,mdist,wind,processes,**extra_args)
            
        print("\n\n")
        print("===============================================")
        print("==       Done with formations problems       ==")
        print("===============================================\n\n")