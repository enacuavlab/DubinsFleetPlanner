# Copyright (C) 2025 Mael FEURGARD <mael.feurgard@enac.fr>
# 
# This file is part of DubinsFleetPlanner.
# 
# DubinsFleetPlanner is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# DubinsFleetPlanner is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with DubinsFleetPlanner.  If not, see <https://www.gnu.org/licenses/>.

import itertools

from Formation import *

from ProblemGenerator import write_pathplanning_problem_to_CSV, AC_PP_Problem, ACStats, Pose3D

def minmax_speeds(stats:list[ACStats]) -> tuple[float,float]:
    return min(s.airspeed for s in stats),max(s.airspeed for s in stats)

def problem_formation_transition(formation_start:Formation, formation_end:Formation, move:Pose3D, stats:list[ACStats]) -> list[AC_PP_Problem]:
    assert len(formation_start.positions) >= len(stats)
    assert len(formation_end.positions) >= len(stats)
    
    output = []
    
    formation_start.center = np.zeros(3)
    formation_end.center = np.zeros(3)
    
    initial_poses = formation_start.apply_rotation().to_barycentric_coords().get_abs_positions()

    final_poses = formation_end.apply_rotation().to_barycentric_coords().move(move).get_abs_positions()
    
    for i,f,s in zip(initial_poses,final_poses,stats):
        output.append(AC_PP_Problem(s,Pose3D.from_array(i),Pose3D.from_array(f),0.))
        
    return output

def problem_from_formation_move(formation:Formation, move:Pose3D, stats:list[ACStats]) -> list[AC_PP_Problem]:    
    return problem_formation_transition(copy.deepcopy(formation),copy.deepcopy(formation),move,stats)


Unit_ForwardShift   = Pose3D(1.,0.,0.,0.)
Unit_LateralShift   = Pose3D(0.,1.,0.,0.)
Unit_HalfTurnRight  = Pose3D(1., 1.,0.,-np.pi/2)
Unit_HalfTurnleft   = Pose3D(1.,-1.,0., np.pi/2)
Unit_FullTurnRight  = Pose3D(0., 2.,0.,-np.pi)
Unit_FullTurnleft   = Pose3D(0.,-2.,0., np.pi)

Turns = [Unit_HalfTurnRight,Unit_HalfTurnleft,Unit_FullTurnRight,Unit_FullTurnleft]
Turns_names = ["HalfTurnRight","HalfTurnLeft","FullTurnRight","FullTurnLeft"]
    
def generate_basic_formation_moves(formation:Formation, stats:list[ACStats], dist:float=1.) -> list[tuple[list[AC_PP_Problem],str]]:
    output = []
    
    
    for p,n in zip(Turns,Turns_names):
        pq = copy.deepcopy(p)
        pq.x *= dist
        pq.y *= dist
        pq.z *= dist
        
        # If the formation is symmetric, discard the right turns (keep only the left ones)
        if formation.symmetry_lr and "right" in n.lower():
            continue
        else:
            output.append((problem_from_formation_move(formation,pq,stats),n))
        
    return output
        

def generate_formation_transitions(formations:list[Formation], stats:list[ACStats], dist:float=1.) -> list[tuple[list[AC_PP_Problem],str]]:
    output = []
    
    m = copy.deepcopy(Unit_ForwardShift)
    m.x *= dist
    m.y *= dist
    m.z *= dist
    
    for f1,f2 in itertools.product(formations,repeat=2):
        if f1 == f2: continue
        
        output.append((problem_formation_transition(
            f1,f2,copy.deepcopy(m),stats
        ),f1.name + "_" + f2.name))
        
    return output

if __name__ =='__main__':
    import argparse,pathlib,os
    
    parser = argparse.ArgumentParser('Formation Path Planning Problem Generator',
                                     description="Generate formation-nased path planning problems from a list of known formations."
                                     "The end points may be generated by shifting and rotating the initila formation, "
                                     "or transitioning from a formation to another",
                                     epilog="Usual statistics: Airliner:\n"
                                     " - Airspeed       : 250 knots (4.166 NM/min)\n"
                                     " - Turn radius    : 1.33 NM\n"
                                     " - Min separation : 5 NM\n\n"
                                     "Lab fixed wing:\n"
                                     " - Airspeed       : 15 m/s\n"
                                     " - Turn radius    : 40 m\n"
                                     " - Min separation : 80 m\n\n",
                                     formatter_class=argparse.RawTextHelpFormatter)
    
    parser.add_argument('nlines',type=int,help='Number of lines of aicraft (total is nlines * ncols)')
    parser.add_argument('ncols',type=int,help='Number of columns of aicraft (total is nlines * ncols)')
    parser.add_argument('mdist',type=float,help='Minimal distance separating aircraft')
    parser.add_argument('output',type=str,help='File prefix name for writing the test case. Will have \'_{test_case_name}.csv\' appended.')
    
    
    parser.add_argument('-v','--airspeed',dest='airspeed',
        type=float, help='Airspeed for all aircraft. Default to 1.',default=1.)

    parser.add_argument('-c','--climb',dest='climb',
        type=float, help='Climb speed for all aircraft. Default to 1.',default=1.)

    parser.add_argument('-r','--turn-radius',dest='turn_radius',
        type=float, help='Minimal turn radius for all aircraft. Default to 1.',default=1.)
    
    args = parser.parse_args()
    
    ncols   = args.ncols
    nlines  = args.nlines
    N       = ncols * nlines
    
    sep = args.mdist
    dest = args.output
    
    airspeed    = args.airspeed
    climb       = args.climb
    turn        = args.turn_radius
    
    stats = [ACStats(i,airspeed,climb,turn) for i in range(N+1)]
    
    all_formations = list_all_formations(ncols,nlines,sep)
    
    dir_path = pathlib.Path(dest).parent
    if not(dir_path.exists()):
        os.makedirs(dir_path)
    
    dist = sep * N
    
    for f in all_formations:
        pb_list = generate_basic_formation_moves(f,stats,dist)
        
        for pb,turn_name in pb_list:
            write_pathplanning_problem_to_CSV(dest+"_"+f.name+"_"+turn_name+".csv",pb,True)
            
    for pb,name in generate_formation_transitions(all_formations,stats,dist):
        write_pathplanning_problem_to_CSV(dest+"_"+name+".csv",pb,True)
    
    